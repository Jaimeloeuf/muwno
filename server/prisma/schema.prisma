// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
//
// This schema is for PostgreSQL therefore certain conventions are followed:
// 1. Snake case is used for table names with all lower cap letters as it is case insensitive.
// 2. All names should be singular form for consistency.
// 3. All datetime values should use ISODateTimeString if possible, see /docs/Prisma DateTime.md
//
// For table fields, the order should be
// 1. PK
// 2. FKs
// 3. Common fields like `createdAt`
// 4. Others
// 5. Relations

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")

  // If you want to use Prisma Migrate, you will need to manually create a shadow database
  // https://neon.tech/docs/guides/prisma-migrate#configure-a-shadow-database-for-prisma-migrate
  // make sure to append ?connect_timeout=10 to the connection string
  // shadowDatabaseUrl = env(“SHADOW_DATABASE_URL”)
}

// This enum mirrors the SubscriptionPlan enum type in domain/
// these are stored as literal string values in the DB.
enum SubscriptionPlan {
  Standard
}

// Table to store all the user organisations
model org {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the orgID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  name      String
  email     String

  // Boolean flag to indicate if Org has been verified by `thepmftool` admins.
  verified Boolean

  // Boolean flag to indicate if Org has an active subscription
  subscribed Boolean

  // Optional as Org are created before they pay for a plan.
  plan SubscriptionPlan?

  // Relationship: ONE org, can have MANY users
  user user[]

  // Relationship: ONE org, can have MANY products
  product product[]

  // Relationship: ONE org, can have MANY pending team member invitations
  team_member_invitation team_member_invitation[]

  // Relationship: ONE org, is ONE (a) Stripe Customer if it is subscribed.
  stripe_customer stripe_customer?
}

// This enum mirrors the Role enum type's name in domain/, but the shortform
// defined for the Role enum cannot be used since DB enum names cannot contain
//  dashes, so these are the literal string values stored in the DB.
enum Role {
  OrgUser
  OrgAdmin
  OrgOwner
}

model user {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  id          String   @unique // See /docs/User ID.md
  createdAt   DateTime @default(now())
  role        Role?
  name        String
  email       String   @unique
  deactivated Boolean  @default(false) // See /docs/Deactivating User Accounts.md

  // orgID/org is optional because a user do not have an org when first created.
  // Relationship: MANY users, can have ONE (the same) org
  org   org?    @relation(fields: [orgID], references: [id])
  orgID String?

  // Relationship: ONE user, can invite MANY team members
  team_member_invitation team_member_invitation[]

  // Relationship: ONE user, can create MANY api keys.
  api_key api_key[]
}

model product {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the productID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  name      String

  // Relationship: MANY products, belong to ONE (the same) org
  org   org    @relation(fields: [orgID], references: [id])
  orgID String

  // Relationship: ONE product, can have MANY survey responses
  pmf_survey_responses pmf_survey_responses[]

  // Relationship: ONE product, can have MANY Tasks
  task task[]

  // Relationship: ONE product, can have MANY MITs
  mit mit[]

  // Relationship: ONE product, can have MANY api keys
  api_key api_key[]
}

model pmf_survey_responses {
  // Using autoincrement as ID needs to be ordered for the queries to work
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // Fixed answer format for now to get started
  a1 Int
  a2 String
  a3 String
  a4 String

  // Relationship: MANY survey responses, belong to ONE (the same) product's survey
  product   product @relation(fields: [productID], references: [id])
  productID String

  // Relationship: ONE survey response, can generate MANY Tasks
  task task[]
}

// Generated tasks for customers to do based on their own customers' feedback.
// Built using responses to question 4 of the PMF survey.
model task {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the taskID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  score     Int
  task      String
  done      Boolean  @default(false)

  // Relationship: MANY Tasks, belong to ONE (the same) product
  product   product @relation(fields: [productID], references: [id])
  productID String

  // Relationship: MANY Tasks, can be generated by ONE (the same) survey response
  response   pmf_survey_responses @relation(fields: [responseID], references: [id])
  responseID Int
}

model mit {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the mitID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  task      String
  done      Boolean  @default(false)

  // Relationship: MANY MITs, belong to ONE (the same) product
  product   product @relation(fields: [productID], references: [id])
  productID String
}

model team_member_invitation {
  // Autoincrementing Int ID needed for queries that require ordering
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  inviteeEmail String   @unique

  // Relationship: MANY Invitations, made by ONE (the same) User
  inviter   user   @relation(fields: [inviterID], references: [id])
  inviterID String

  // Relationship: MANY Invitations, belong to ONE (the same) Organisation
  org   org    @relation(fields: [orgID], references: [id])
  orgID String
}

model stripe_webhook_event {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Use Stripe's unique event ID as the indempotency key
  id        String   @unique
  // Time of DB insertion, not time where Stripe created the event
  createdAt DateTime @default(now())
  type      String
  livemode  Boolean
  processed Boolean
}

// Table to store Stripe specific details like its customer and subscription ID.
model stripe_customer {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Stripe's unique customer ID
  id        String   @unique
  createdAt DateTime @default(now())

  // Relationship: ONE Stripe Customer, is created for ONE (each) paying Organisation
  org   org    @relation(fields: [orgID], references: [id])
  orgID String @unique
// Table for next actions to execute on Stripe SetupIntent completing successfully.
model stripe_setup_next {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Stripe's unique SetupIntent ID
  id        String   @unique
  createdAt DateTime @default(now())

  // Next action is stored as a JSON object since different next actions can be
  // structured differently.
  next Json
}

model api_key {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the apiKeyID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  hash      String   @unique
  prefix    String   @unique
  // description String?

  // Relationship: MANY api keys, allows access to ONE (the same) product
  product   product @relation(fields: [productID], references: [id])
  productID String

  // Relationship: MANY api keys, can be created by ONE (the same) user
  createdBy user   @relation(fields: [userID], references: [id])
  userID    String
}
