// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
//
// This schema is for PostgreSQL therefore certain conventions are followed:
// 1. Snake case is used for table names with all lower cap letters as it is case insensitive.
// 2. All names should be singular form for consistency.
// 3. All datetime values should use ISODateTimeString if possible, see /docs/Prisma DateTime.md
//
// For table fields, the order should be
// 1. PK
// 2. FKs
// 3. Common fields like `createdAt`
// 4. Others
// 5. Relations

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")

  // If you want to use Prisma Migrate, you will need to manually create a shadow database
  // https://neon.tech/docs/guides/prisma-migrate#configure-a-shadow-database-for-prisma-migrate
  // make sure to append ?connect_timeout=10 to the connection string
  // shadowDatabaseUrl = env(“SHADOW_DATABASE_URL”)
}

// Table to store all the possible subscription plans
model plan {
  // Using autoincrement as ID needs to be ordered for the queries to work
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  name      String
  active    Boolean

  // Relationship: ONE plan, can be used by MANY orgs
  org org[]
}

// Table to store all the user organisations
model org {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the orgID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  name      String

  // Relationship: MANY orgs, can have ONE (the same) plan
  plan   plan @relation(fields: [planID], references: [id])
  planID Int

  // Relationship: ONE org, can have MANY users
  user user[]

  // Relationship: ONE org, can have MANY products
  product product[]

  // Relationship: ONE org, can have MANY pending team member invitations
  team_member_invitation team_member_invitation[]
}

// This enum mirrors the Role enum type's name in domain/, but the shortform
// defined for the Role enum cannot be used since DB enum names cannot contain
//  dashes, so these are the literal string values stored in the DB.
enum Role {
  OrgUser
  OrgAdmin
  OrgOwner
}

model user {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  id          String   @unique // See /docs/User ID.md
  createdAt   DateTime @default(now())
  role        Role?
  name        String
  email       String   @unique
  deactivated Boolean  @default(false) // See /docs/Deactivating User Accounts.md

  // orgID/org is optional because a user do not have an org when first created.
  // Relationship: MANY users, can have ONE (the same) org
  org   org?    @relation(fields: [orgID], references: [id])
  orgID String?

  // Relationship: ONE user, can invite MANY team members
  team_member_invitation team_member_invitation[]
}

model product {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the productID
  id         String   @unique @default(cuid())
  createdAt  DateTime @default(now())
  name       String
  // This is a surveyModeID but surveyMode is not stored in DB so using Int.
  // See the `SurveyMode` enum type in domain/
  surveyMode Int

  // Relationship: MANY products, belong to ONE (the same) org
  org   org    @relation(fields: [orgID], references: [id])
  orgID String

  // Relationship: ONE product, can have MANY survey responses
  pmf_survey_responses pmf_survey_responses[]

  // Relationship: ONE product, can have MANY Tasks
  task task[]

  // Relationship: ONE product, can have MANY MITs
  mit mit[]
}

model pmf_survey_responses {
  // Using autoincrement as ID needs to be ordered for the queries to work
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  // Fixed answer format for now to get started
  a1 Int
  a2 String
  a3 String
  a4 String

  // Relationship: MANY survey responses, belong to ONE (the same) product's survey
  product   product @relation(fields: [productID], references: [id])
  productID String

  // Relationship: ONE survey response, can generate MANY Tasks
  task task[]
}

// Generated tasks for customers to do based on their own customers' feedback.
// Built using responses to question 4 of the PMF survey.
model task {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the taskID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  task      String
  done      Boolean  @default(false)

  // Relationship: MANY Tasks, belong to ONE (the same) product
  product   product @relation(fields: [productID], references: [id])
  productID String

  // Relationship: MANY Tasks, can be generated by ONE (the same) survey response
  response   pmf_survey_responses @relation(fields: [responseID], references: [id])
  responseID Int
}

model mit {
  // Autoincrementing Int ID needed for queries that require ordering
  iid Int @id @default(autoincrement())

  // Unique random string ID as the mitID
  id        String   @unique @default(cuid())
  createdAt DateTime @default(now())
  task      String
  done      Boolean  @default(false)

  // Relationship: MANY MITs, belong to ONE (the same) product
  product   product @relation(fields: [productID], references: [id])
  productID String
}

model team_member_invitation {
  // Autoincrementing Int ID needed for queries that require ordering
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now())
  inviteeEmail String   @unique

  // Relationship: MANY Invitations, made by ONE (the same) User
  inviter   user   @relation(fields: [inviterID], references: [id])
  inviterID String

  // Relationship: MANY Invitations, belong to ONE (the same) Organisation
  org   org    @relation(fields: [orgID], references: [id])
  orgID String
}
