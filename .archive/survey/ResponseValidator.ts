import z from 'zod';
import type { Survey } from './SurveyValidator';

/**
 * @todo add custom specific error messages for all the parsers like `title`
 */
export const SurveyResponseParserV1 = z
  .object({
    /**
     * This is a fixed literal as a custom Zod parser will be defined
     * for every specific schema version.
     */
    schemaVersion: z.literal('1'),

    /**
     * Response ID
     *
     * @todo
     * ID might by generated by hashing this whole document so that we can check
     * if contents has been changed easily use hashing.
     * Otherwise, a GUID must be generated for this.
     */
    id: z.string().nonempty({ message: 'Response ID cannot be empty string' }),

    /**
     * Survey ID
     */
    surveyID: z
      .string()
      .nonempty({ message: 'Survey ID cannot be empty string' }),

    /**
     * Time of when user responded in ISO DateTime string.
     * Use `new Date().toISOString()`
     */
    createdAt: z.string().datetime({
      precision: 3,
      message:
        'createdAt must be ISO DateTime with 3 digit sub-second precision',
    }),

    /**
     * The Survey Responder's id
     * It is optional for now, but we might want some way to tag the user so
     * that they can reference back to the user and communicate with them.
     * Current workaround is to have a question to ask for their email/number.
     */
    createdBy: z
      .string()
      .nonempty({ message: 'createdBy cannot be empty string' })
      .optional(),

    // @todo
    // Might want to have an array of tags so that product teams can tag the users

    /**
     * Survey answers.
     *
     * This is an array of survey answers of any shape, as this parser only parse
     * and validates the general SurveyResponse shape, not the specific Survey's
     * answers to make sure that they are valid.
     */
    ans: z.array(z.any()).min(1, { message: 'Must have at least 1 answer' }),
  })
  // Error on unknown keys instead of stripping them out during parsing
  .strict();

/**
 * SurveyResponse contains the actual response/answers to the questions and other metadata
 *
 * If there are multiple versions of response types,
 * this will be a union type of all of them.
 */
export type SurveyResponse = z.infer<typeof SurveyResponseParserV1>;

/**
 * Validate Survey Response before saving it into data source
 */
export function validateResponse(
  surveyResponse: SurveyResponse,
  surveyID: Survey['id'],
) {
  surveyID;

  // If there are multiple versions of response types, switch to use specific parser based on version key
  // This only validates if it is a proper Response, it does not validate for the specific survey schema
  const validationResult = SurveyResponseParserV1.safeParse(surveyResponse);

  if (!validationResult.success) {
    console.log(
      'Failed validation',
      validationResult.error.errors.map((error) => error.message),
    );

    return false;
  }

  return true;
}
